---
layout: post
title:  "C++ Primer 5th C15_1 基类和派生类及类型转换"
date:   2018-11-27 11:31:13
categories: c++
permalink: /archivers/c++_primer_5th_C15_1
---
# 15.1 OOP:概述

面向对象程序设计的核心思想是数据抽象，继承和动态绑定。

通过数据抽象，将类的接口和实现分离。
通过继承，可以定义相似的类型并对其相似关系建模。
使用动态绑定，可以在一定程度上忽略相似类型间的区别。

# 15.2.1 定义基类

一般基类需要有虚析构函数，并将虚函数声明为 virtual ，virtual关键字只出现在声明。

如果一个函数在基类是虚函数，那么子类中隐式的也是虚函数。


任何构造函数以外的非静态函数都可以是虚函数。

成员函数如果是虚函数，那么解析将发生在运行时。（动态绑定）。成员函数如果没有声明为虚函数，则解析过程发生在编译期。


派生类能够访问公有成员，但不能访问私有成员。不过为了能够让派生类访问基类成员同时禁止其他用户访问，我们使用protected说明这种成员。

# 15.2.2 定义派生类

派生类使用派生类列表指出它是从哪些类继承来的。
例如：
```c++
class Derived : public Base
{
    ...
};
```
其中每个基类前可以有访问说明符。（public, protected, private中的一个）
对于class来说，默认为private；对于struct来说，默认为public。

派生类必须将继承来的成员函数中，需要覆盖的那些重新声明。

如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外我们能将公有派生类型的对象绑定到基类的引用或指针上。

大多数类都只继承自一个类，这种形式的继承为单继承。


**派生类中的虚函数**

派生类经常覆盖他继承的虚函数。如果派生类没有覆盖的话，会直接继承基类中的版本，此时行为类似于普通成员函数。

派生类可以在覆盖的虚函数前声明virtual，但不是必须的。

c++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。
具体做法是在形参列表后面，或const成员函数的const关键词后面，或引用成员函数的引用限定符后面添加一个关键词override。

**派生类对象及派生类向基类的类型转换**

一个派生类对象包含多个组成部分。
* 派生类自己定义的成员的子对象
* 继承的基类的对应的子对象（可能有多个）

c++标准没有规定派生类对象在内存中如何分布，但我们可以认为对象如下面分布：

|Derived对象|
|-|
|Base继承而来的|
|Derived自定义的|

因为派生类含有基类的组成部分，我们可以把派生类的对象当作基类对象使用。
```c++
Base item;      //基类
Derived item2;  //派生类
Base *p = &item;//p指向Base对象
p = &item2;     //p指向Derived的Base部分
Base &r = item2;//r绑定到Derived的Base部分
```

这种转换通常称为派生类到基类的类型转换。编译器可以隐式地执行派生类到基类的转换。这意味着派生类对象或派生类对象的引用可以用在需要积累引用的地方。指针同理。

**派生类构造函数**

尽管派生类含有基类继承来的成员，但派生类不能直接初始化基类的成员。派生了也必须使用基类的构造函数来初始化基类部分。

派生类的基类部分与自己的数据成员都是在构造函数的初始化阶段进行初始化的。

```c++
Derived(...):
    Base(...), data1(...), data2(...)
    {}
```

该函数使用Base的构造函数来构造Derived的基类部分。在基类构造函数体结束后，我们构造的对象的积累部分也就完成了初始化，接下来初始化派生类对应的自定义成员，最后构造函数的函数体内的内容。

如果没有特别指出，派生类对象的基类部分会像数据成员一样进行默认初始化。如果想用其它的构造函数，使用类名加圆括号内的实参列表的形式为构造函数提供初始值。

顺序： 基类->声明顺序依次初始化派生类的成员。

**派生类使用基类的成员**

派生类可以访问基类的public成员和protected成员。

每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生的基类部分也是如此。

**继承与静态成员**

如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义。不管派生出来多少个派生类，静态成员只存在唯一的实例。

静态成员遵循访问控制规则，如果基类中的成员是private的，则派生类无权访问它。

```c++
class Base{
public:
    static void static_func();
};
class Derived : public Base
{
    void f(const Derived& obj)
    {
        Base::static_func();  //okay
        Derived::static_func();  //okay
        obj.static_func();  //okay
        static_func();  //okay
    }
};
```

**派生类的声明**

派生类声明不需要包含他的派生类列表。
```c++
class Derived : public Base; //错误
class Derived; //正确
```

**被用作基类的类**

如果一个类只被声明，而未定义，那么它不能被用作基类。

这是为了确定派生类的成员，并保证一个类不能派生它本身。

```c++
class Base_undefined;
// 错误，Base_undefined必须被定义
class Derived : public Base_undefined;
```

Base是D1的直接基类，是D2的间接基类。直接基类出现在初始化列表中，而间接基类有派生类通过直接基类继承而来。

```c++
class Base { ... };
class D1 : public Base { ... };
class D2 : public D1 { ... };
```

**防止继承的发生**

c++11提供了一种防止继承发生的方法，即在类名后加一个关键字final。

```c++
class NoDerived final {...};
class Bad : NoDerived {...}; // 无法继承
class Base {...};
class Last final : Base {...}
class Bad2 : Last {...} //无法继承
```

# 15.2.3 类型转换与继承

通常如果引用或指针绑定到一个对象上，类型需要是一致的，或者对象的类型有一个可接受的const类型转换规则。

但存在继承关系的是一个重要的例外。可以将基类的指针或引用绑定到派生类对象上。如果我们有一个基类的指针或引用，我们实际上不知道该对象具体是基类的对象，还是派生类的对象。

智能指针类也支持派生类到基类类型的转换。

**静态类型和动态类型**

当我们使用存在继承关系的类型时，必须将一个变量的静态类型与动态类型区分开来。

静态类型：编译时一致的类型，他是变量声明时的类型或表达式生成的类型。

动态类型：变量或表达式在内存中的对象的类型，在运行时才能确定。

如果表达式既不是引用也不是指针，则它的动态类型和静态类型是一致的。

**不存在由基类向派生类的隐式类型转换**

由于派生类总是包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上。一个基类的对象既可以以独立的形式存在，也可以以派生类的一部分存在。

这种情况下，一个基类类型不一定会含有派生类的成员，所以不具有基类向派生类的自动类型转换。

由于动态类型在运行时被确定，无法静态的保证转换的有效性，所以即使将一个基类指针或引用绑定到派生类对象上，这种转换依然不能执行。

```c++
Base base;
Derived * bp = &base; //error
Derived & rp = base; //error
Derived de;
Base * dp = &de;
Derived * bp2 = dp;  //error
```

为了在动态类型允许转换的情况下完成这一转换，我们使用 dynamic_cast 请求一个类型转换。这个转换的安全检查在运行时进行。由于这一操作依赖虚函数表，所以基类需要有一个或多个虚函数。

同样的，如果我们十分自信一个基类向派生类的转换是安全的，可以使用 static_cast 来强制覆盖掉编译器的检查工作。


**在对象之间不存在类型转换**

上述讨论的是指针或引用类型的自动类型转换。在派生类和基类的对象间不存在这样的转换。

考虑我们想赋值或初始化一个对象，实际上是在调用某个函数。而其参数通常是一个对应类型的const引用。
因此基类的拷贝或移动操作可以接受一个转换为基类引用的派生类对象。显然这里只能处理基类的成员。

```c++
Derived de;
Base item(de);  //Base::Base(const Base&)构造函数
item = de;      //Base::operator=(const Base&)
```

这种情况下，de的Derived部分就被切掉了。只有基类部分会被拷贝移动或赋值，派生类部分被忽略。

**总结**

* 派生类到基类的自动类型转换只对指针或引用有效。
* 基类向派生类不存在隐式类型转换。
* 派生类向基类的类型转换可能会由于访问受限而不可行。
* 虽然基类会生成拷贝控制成员，但只能处理基类的内容。


